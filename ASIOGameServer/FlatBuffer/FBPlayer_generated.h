// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FBPLAYER_FBPLAYER_H_
#define FLATBUFFERS_GENERATED_FBPLAYER_FBPLAYER_H_

#include "flatbuffers/flatbuffers.h"

namespace FBPlayer {

	struct Vec3;

	struct Player;

	struct Weapon;

	enum Action {
		Action_MoveStart = 0,
		Action_Moving = 1,
		Action_StopMove = 2,
		Action_JumStart = 3,
		Action_Jumping = 4,
		Action_StopJump = 5,
		Action_Attack = 6,
		Action_MIN = Action_MoveStart,
		Action_MAX = Action_Attack
	};

	inline const Action(&EnumValuesAction())[7]{
		static const Action values[] = {
		Action_MoveStart,
		Action_Moving,
		Action_StopMove,
		Action_JumStart,
		Action_Jumping,
		Action_StopJump,
		Action_Attack
	};
	return values;
	}

		inline const char * const *EnumNamesAction() {
		static const char * const names[] = {
			"MoveStart",
			"Moving",
			"StopMove",
			"JumStart",
			"Jumping",
			"StopJump",
			"Attack",
			nullptr
		};
		return names;
	}

	inline const char *EnumNameAction(Action e) {
		const size_t index = static_cast<int>(e);
		return EnumNamesAction()[index];
	}

	MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
	private:
		float x_;
		float y_;
		float z_;

	public:
		Vec3() {
			memset(this, 0, sizeof(Vec3));
		}
		Vec3(float _x, float _y, float _z)
			: x_(flatbuffers::EndianScalar(_x)),
			y_(flatbuffers::EndianScalar(_y)),
			z_(flatbuffers::EndianScalar(_z)) {
		}
		float x() const {
			return flatbuffers::EndianScalar(x_);
		}
		float y() const {
			return flatbuffers::EndianScalar(y_);
		}
		float z() const {
			return flatbuffers::EndianScalar(z_);
		}
	};
	STRUCT_END(Vec3, 12);

	struct Player FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
		enum {
			VT_CURRENTACTION = 4,
			VT_CODE = 6,
			VT_POS = 8,
			VT_VELOCITY = 10,
			VT_SPEED = 12,
			VT_HP = 14,
			VT_WEAPONS = 16
		};
		Action currentAction() const {
			return static_cast<Action>(GetField<int8_t>(VT_CURRENTACTION, 0));
		}
		int32_t code() const {
			return GetField<int32_t>(VT_CODE, 0);
		}
		const Vec3 *pos() const {
			return GetStruct<const Vec3 *>(VT_POS);
		}
		const Vec3 *velocity() const {
			return GetStruct<const Vec3 *>(VT_VELOCITY);
		}
		float speed() const {
			return GetField<float>(VT_SPEED, 0.0f);
		}
		float hp() const {
			return GetField<float>(VT_HP, 0.0f);
		}
		const Weapon *weapons() const {
			return GetPointer<const Weapon *>(VT_WEAPONS);
		}
		bool Verify(flatbuffers::Verifier &verifier) const {
			return VerifyTableStart(verifier) &&
				VerifyField<int8_t>(verifier, VT_CURRENTACTION) &&
				VerifyField<int32_t>(verifier, VT_CODE) &&
				VerifyField<Vec3>(verifier, VT_POS) &&
				VerifyField<Vec3>(verifier, VT_VELOCITY) &&
				VerifyField<float>(verifier, VT_SPEED) &&
				VerifyField<float>(verifier, VT_HP) &&
				VerifyOffset(verifier, VT_WEAPONS) &&
				verifier.VerifyTable(weapons()) &&
				verifier.EndTable();
		}
	};

	struct PlayerBuilder {
		flatbuffers::FlatBufferBuilder &fbb_;
		flatbuffers::uoffset_t start_;
		void add_currentAction(Action currentAction) {
			fbb_.AddElement<int8_t>(Player::VT_CURRENTACTION, static_cast<int8_t>(currentAction), 0);
		}
		void add_code(int32_t code) {
			fbb_.AddElement<int32_t>(Player::VT_CODE, code, 0);
		}
		void add_pos(const Vec3 *pos) {
			fbb_.AddStruct(Player::VT_POS, pos);
		}
		void add_velocity(const Vec3 *velocity) {
			fbb_.AddStruct(Player::VT_VELOCITY, velocity);
		}
		void add_speed(float speed) {
			fbb_.AddElement<float>(Player::VT_SPEED, speed, 0.0f);
		}
		void add_hp(float hp) {
			fbb_.AddElement<float>(Player::VT_HP, hp, 0.0f);
		}
		void add_weapons(flatbuffers::Offset<Weapon> weapons) {
			fbb_.AddOffset(Player::VT_WEAPONS, weapons);
		}
		explicit PlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
			: fbb_(_fbb) {
			start_ = fbb_.StartTable();
		}
		PlayerBuilder &operator=(const PlayerBuilder &);
		flatbuffers::Offset<Player> Finish() {
			const auto end = fbb_.EndTable(start_);
			auto o = flatbuffers::Offset<Player>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Player> CreatePlayer(
		flatbuffers::FlatBufferBuilder &_fbb,
		Action currentAction = Action_MoveStart,
		int32_t code = 0,
		const Vec3 *pos = 0,
		const Vec3 *velocity = 0,
		float speed = 0.0f,
		float hp = 0.0f,
		flatbuffers::Offset<Weapon> weapons = 0) {
		PlayerBuilder builder_(_fbb);
		builder_.add_weapons(weapons);
		builder_.add_hp(hp);
		builder_.add_speed(speed);
		builder_.add_velocity(velocity);
		builder_.add_pos(pos);
		builder_.add_code(code);
		builder_.add_currentAction(currentAction);
		return builder_.Finish();
	}

	struct Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
		enum {
			VT_NAME = 4,
			VT_DAMAGE = 6
		};
		const flatbuffers::String *name() const {
			return GetPointer<const flatbuffers::String *>(VT_NAME);
		}
		int16_t damage() const {
			return GetField<int16_t>(VT_DAMAGE, 0);
		}
		bool Verify(flatbuffers::Verifier &verifier) const {
			return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.Verify(name()) &&
				VerifyField<int16_t>(verifier, VT_DAMAGE) &&
				verifier.EndTable();
		}
	};

	struct WeaponBuilder {
		flatbuffers::FlatBufferBuilder &fbb_;
		flatbuffers::uoffset_t start_;
		void add_name(flatbuffers::Offset<flatbuffers::String> name) {
			fbb_.AddOffset(Weapon::VT_NAME, name);
		}
		void add_damage(int16_t damage) {
			fbb_.AddElement<int16_t>(Weapon::VT_DAMAGE, damage, 0);
		}
		explicit WeaponBuilder(flatbuffers::FlatBufferBuilder &_fbb)
			: fbb_(_fbb) {
			start_ = fbb_.StartTable();
		}
		WeaponBuilder &operator=(const WeaponBuilder &);
		flatbuffers::Offset<Weapon> Finish() {
			const auto end = fbb_.EndTable(start_);
			auto o = flatbuffers::Offset<Weapon>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Weapon> CreateWeapon(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> name = 0,
		int16_t damage = 0) {
		WeaponBuilder builder_(_fbb);
		builder_.add_name(name);
		builder_.add_damage(damage);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Weapon> CreateWeaponDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *name = nullptr,
		int16_t damage = 0) {
		return FBPlayer::CreateWeapon(
			_fbb,
			name ? _fbb.CreateString(name) : 0,
			damage);
	}

	inline const FBPlayer::Player *GetPlayer(const void *buf) {
		return flatbuffers::GetRoot<FBPlayer::Player>(buf);
	}

	inline const FBPlayer::Player *GetSizePrefixedPlayer(const void *buf) {
		return flatbuffers::GetSizePrefixedRoot<FBPlayer::Player>(buf);
	}

	inline bool VerifyPlayerBuffer(
		flatbuffers::Verifier &verifier) {
		return verifier.VerifyBuffer<FBPlayer::Player>(nullptr);
	}

	inline bool VerifySizePrefixedPlayerBuffer(
		flatbuffers::Verifier &verifier) {
		return verifier.VerifySizePrefixedBuffer<FBPlayer::Player>(nullptr);
	}

	inline void FinishPlayerBuffer(
		flatbuffers::FlatBufferBuilder &fbb,
		flatbuffers::Offset<FBPlayer::Player> root) {
		fbb.Finish(root);
	}

	inline void FinishSizePrefixedPlayerBuffer(
		flatbuffers::FlatBufferBuilder &fbb,
		flatbuffers::Offset<FBPlayer::Player> root) {
		fbb.FinishSizePrefixed(root);
	}

}  // namespace FBPlayer

#endif  // FLATBUFFERS_GENERATED_FBPLAYER_FBPLAYER_H_
